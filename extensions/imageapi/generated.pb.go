// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: generated.proto

package imageapi

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	golang_proto "github.com/golang/protobuf/proto"
	github_com_hpc_kraken_extensions_imageapi_customtypes "github.com/hpc/kraken/extensions/imageapi/customtypes"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type ContainerNamespace int32

const (
	ContainerNamespace_CGROUP ContainerNamespace = 0
	ContainerNamespace_IPC    ContainerNamespace = 1
	ContainerNamespace_NET    ContainerNamespace = 2
	ContainerNamespace_MNT    ContainerNamespace = 3
	ContainerNamespace_PID    ContainerNamespace = 4
	ContainerNamespace_TIME   ContainerNamespace = 5
	ContainerNamespace_USER   ContainerNamespace = 6
	ContainerNamespace_UTS    ContainerNamespace = 7
)

var ContainerNamespace_name = map[int32]string{
	0: "CGROUP",
	1: "IPC",
	2: "NET",
	3: "MNT",
	4: "PID",
	5: "TIME",
	6: "USER",
	7: "UTS",
}

var ContainerNamespace_value = map[string]int32{
	"CGROUP": 0,
	"IPC":    1,
	"NET":    2,
	"MNT":    3,
	"PID":    4,
	"TIME":   5,
	"USER":   6,
	"UTS":    7,
}

func (x ContainerNamespace) String() string {
	return proto.EnumName(ContainerNamespace_name, int32(x))
}

func (ContainerNamespace) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e6ed858329eb171d, []int{0}
}

type ContainerState int32

const (
	ContainerState_CREATED  ContainerState = 0
	ContainerState_RUNNING  ContainerState = 1
	ContainerState_STOPPING ContainerState = 2
	ContainerState_EXITED   ContainerState = 3
	ContainerState_DEAD     ContainerState = 4
)

var ContainerState_name = map[int32]string{
	0: "CREATED",
	1: "RUNNING",
	2: "STOPPING",
	3: "EXITED",
	4: "DEAD",
}

var ContainerState_value = map[string]int32{
	"CREATED":  0,
	"RUNNING":  1,
	"STOPPING": 2,
	"EXITED":   3,
	"DEAD":     4,
}

func (x ContainerState) String() string {
	return proto.EnumName(ContainerState_name, int32(x))
}

func (ContainerState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e6ed858329eb171d, []int{1}
}

type Mount_MountKind int32

const (
	Mount_MOUNT_KIND_OVERLAY Mount_MountKind = 0
	Mount_MOUNT_KIND_RBD     Mount_MountKind = 1
)

var Mount_MountKind_name = map[int32]string{
	0: "MOUNT_KIND_OVERLAY",
	1: "MOUNT_KIND_RBD",
}

var Mount_MountKind_value = map[string]int32{
	"MOUNT_KIND_OVERLAY": 0,
	"MOUNT_KIND_RBD":     1,
}

func (x Mount_MountKind) String() string {
	return proto.EnumName(Mount_MountKind_name, int32(x))
}

func (Mount_MountKind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e6ed858329eb171d, []int{3, 0}
}

type CustomType struct {
	Secret               *github_com_hpc_kraken_extensions_imageapi_customtypes.Secret `protobuf:"bytes,1,opt,name=secret,proto3,customtype=github.com/hpc/kraken/extensions/imageapi/customtypes.Secret" json:"secret,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                                      `json:"-"`
	XXX_unrecognized     []byte                                                        `json:"-"`
	XXX_sizecache        int32                                                         `json:"-"`
}

func (m *CustomType) Reset()         { *m = CustomType{} }
func (m *CustomType) String() string { return proto.CompactTextString(m) }
func (*CustomType) ProtoMessage()    {}
func (*CustomType) Descriptor() ([]byte, []int) {
	return fileDescriptor_e6ed858329eb171d, []int{0}
}
func (m *CustomType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CustomType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CustomType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CustomType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CustomType.Merge(m, src)
}
func (m *CustomType) XXX_Size() int {
	return m.Size()
}
func (m *CustomType) XXX_DiscardUnknown() {
	xxx_messageInfo_CustomType.DiscardUnknown(m)
}

var xxx_messageInfo_CustomType proto.InternalMessageInfo

func (*CustomType) XXX_MessageName() string {
	return "ImageAPI.CustomType"
}

// The `container` option describes a minimally namespaced container.
//
// A container is identified by a service-provided unique numeric `pid`.
//
// Optionally, a container can be provided with a `name`.  The name must
// be unique.  Containers can be referenced by `name` if provided.
type Container struct {
	Command string `protobuf:"bytes,1,opt,name=command,proto3" json:"command,omitempty"`
	Id      int64  `protobuf:"varint,2,opt,name=id,proto3" json:"id,omitempty"`
	Logfile string `protobuf:"bytes,3,opt,name=logfile,proto3" json:"logfile,omitempty"`
	Mount   *Mount `protobuf:"bytes,4,opt,name=mount,proto3" json:"mount,omitempty"`
	// name is an optional identifier for the container.  Name must be unique.
	Name string `protobuf:"bytes,5,opt,name=name,proto3" json:"name,omitempty"`
	// A list of Linux namespaces to use.
	//
	// Note: This is currently unused.  All containers currently get `mnt` and `pid`.
	//       It's here as a placeholder for future use.
	Namespaces []ContainerNamespace `protobuf:"varint,6,rep,packed,name=namespaces,proto3,enum=ImageAPI.ContainerNamespace" json:"namespaces,omitempty"`
	// When read, this contains the current container state. On creation, this requests the initial state (valid options: `created` or `running`). The default is `created`.
	State ContainerState `protobuf:"varint,7,opt,name=state,proto3,enum=ImageAPI.ContainerState" json:"state,omitempty"`
	// When `systemd` is set to `true`, we will assume that this container will run `systemd`, and perform the necessary magic dance to make systemd run inside of the container. The default is `false`.
	Systemd              bool     `protobuf:"varint,8,opt,name=systemd,proto3" json:"systemd,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Container) Reset()         { *m = Container{} }
func (m *Container) String() string { return proto.CompactTextString(m) }
func (*Container) ProtoMessage()    {}
func (*Container) Descriptor() ([]byte, []int) {
	return fileDescriptor_e6ed858329eb171d, []int{1}
}
func (m *Container) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Container) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Container.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Container) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Container.Merge(m, src)
}
func (m *Container) XXX_Size() int {
	return m.Size()
}
func (m *Container) XXX_DiscardUnknown() {
	xxx_messageInfo_Container.DiscardUnknown(m)
}

var xxx_messageInfo_Container proto.InternalMessageInfo

func (m *Container) GetCommand() string {
	if m != nil {
		return m.Command
	}
	return ""
}

func (m *Container) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Container) GetLogfile() string {
	if m != nil {
		return m.Logfile
	}
	return ""
}

func (m *Container) GetMount() *Mount {
	if m != nil {
		return m.Mount
	}
	return nil
}

func (m *Container) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Container) GetNamespaces() []ContainerNamespace {
	if m != nil {
		return m.Namespaces
	}
	return nil
}

func (m *Container) GetState() ContainerState {
	if m != nil {
		return m.State
	}
	return ContainerState_CREATED
}

func (m *Container) GetSystemd() bool {
	if m != nil {
		return m.Systemd
	}
	return false
}

func (*Container) XXX_MessageName() string {
	return "ImageAPI.Container"
}

type Error struct {
	Code                 int64    `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Message              string   `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Error) Reset()         { *m = Error{} }
func (m *Error) String() string { return proto.CompactTextString(m) }
func (*Error) ProtoMessage()    {}
func (*Error) Descriptor() ([]byte, []int) {
	return fileDescriptor_e6ed858329eb171d, []int{2}
}
func (m *Error) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Error) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Error.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Error) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Error.Merge(m, src)
}
func (m *Error) XXX_Size() int {
	return m.Size()
}
func (m *Error) XXX_DiscardUnknown() {
	xxx_messageInfo_Error.DiscardUnknown(m)
}

var xxx_messageInfo_Error proto.InternalMessageInfo

func (m *Error) GetCode() int64 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *Error) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (*Error) XXX_MessageName() string {
	return "ImageAPI.Error"
}

// Generically address mounts by kind and ID or definition
// Either an `mount_id` or a mount definition must be supplied.
// If both are supplied, the mount definition will be ignored.
// If `mount_id` is specified, then the kind/id will be used to reference that mount.
// If no `mount_id` is supplied a defition of type `kind` must be present.
type Mount struct {
	Kind                 Mount_MountKind `protobuf:"varint,1,opt,name=kind,proto3,enum=ImageAPI.Mount_MountKind" json:"kind,omitempty"`
	MountId              int64           `protobuf:"varint,2,opt,name=mount_id,json=mountId,proto3" json:"mount_id,omitempty"`
	Overlay              *MountOverlay   `protobuf:"bytes,3,opt,name=overlay,proto3" json:"overlay,omitempty"`
	Rbd                  *MountRbd       `protobuf:"bytes,4,opt,name=rbd,proto3" json:"rbd,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *Mount) Reset()         { *m = Mount{} }
func (m *Mount) String() string { return proto.CompactTextString(m) }
func (*Mount) ProtoMessage()    {}
func (*Mount) Descriptor() ([]byte, []int) {
	return fileDescriptor_e6ed858329eb171d, []int{3}
}
func (m *Mount) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Mount) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Mount.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Mount) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Mount.Merge(m, src)
}
func (m *Mount) XXX_Size() int {
	return m.Size()
}
func (m *Mount) XXX_DiscardUnknown() {
	xxx_messageInfo_Mount.DiscardUnknown(m)
}

var xxx_messageInfo_Mount proto.InternalMessageInfo

func (m *Mount) GetKind() Mount_MountKind {
	if m != nil {
		return m.Kind
	}
	return Mount_MOUNT_KIND_OVERLAY
}

func (m *Mount) GetMountId() int64 {
	if m != nil {
		return m.MountId
	}
	return 0
}

func (m *Mount) GetOverlay() *MountOverlay {
	if m != nil {
		return m.Overlay
	}
	return nil
}

func (m *Mount) GetRbd() *MountRbd {
	if m != nil {
		return m.Rbd
	}
	return nil
}

func (*Mount) XXX_MessageName() string {
	return "ImageAPI.Mount"
}

// `mount_overlay` describes an Overlayfs mount.  All mount points must be RBD ID's.
// At very least, `lower` must be specified.  If `upper` length is zero, no `upper`
// mounts will be used.  `workdir` will be assigned automatically.
//
// If the mounts specified in `lower` are specifications and not ID references, they
// will be recursively mounted/attached.
//
// Overlay mounts are identified by their uppermost `lower` ID.
type MountOverlay struct {
	Id int64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// This is an array of mount specifications to be used (in order) as lower mounts for the overlay.
	Lower      []*Mount `protobuf:"bytes,2,rep,name=lower,proto3" json:"lower,omitempty"`
	Mountpoint string   `protobuf:"bytes,3,opt,name=mountpoint,proto3" json:"mountpoint,omitempty"`
	Refs       int64    `protobuf:"varint,4,opt,name=refs,proto3" json:"refs,omitempty"`
	// currently, upperdir is always a directory in mountDir
	Upperdir             string   `protobuf:"bytes,5,opt,name=upperdir,proto3" json:"upperdir,omitempty"`
	Workdir              string   `protobuf:"bytes,6,opt,name=workdir,proto3" json:"workdir,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MountOverlay) Reset()         { *m = MountOverlay{} }
func (m *MountOverlay) String() string { return proto.CompactTextString(m) }
func (*MountOverlay) ProtoMessage()    {}
func (*MountOverlay) Descriptor() ([]byte, []int) {
	return fileDescriptor_e6ed858329eb171d, []int{4}
}
func (m *MountOverlay) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MountOverlay) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MountOverlay.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MountOverlay) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MountOverlay.Merge(m, src)
}
func (m *MountOverlay) XXX_Size() int {
	return m.Size()
}
func (m *MountOverlay) XXX_DiscardUnknown() {
	xxx_messageInfo_MountOverlay.DiscardUnknown(m)
}

var xxx_messageInfo_MountOverlay proto.InternalMessageInfo

func (m *MountOverlay) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *MountOverlay) GetLower() []*Mount {
	if m != nil {
		return m.Lower
	}
	return nil
}

func (m *MountOverlay) GetMountpoint() string {
	if m != nil {
		return m.Mountpoint
	}
	return ""
}

func (m *MountOverlay) GetRefs() int64 {
	if m != nil {
		return m.Refs
	}
	return 0
}

func (m *MountOverlay) GetUpperdir() string {
	if m != nil {
		return m.Upperdir
	}
	return ""
}

func (m *MountOverlay) GetWorkdir() string {
	if m != nil {
		return m.Workdir
	}
	return ""
}

func (*MountOverlay) XXX_MessageName() string {
	return "ImageAPI.MountOverlay"
}

// mount_rbd describes an RBD mount.  This must have at least and RBD ID associated with it
// (which becomes the mount's ID), and a provided filesystem type.
//
// Either `rbd_id` or `rbd` must be specified.  If both are specified, `rbd` will be ignored.
//
// If `rbd` is specified and `rbd_id` is omitted, the RBD will first be attached, and will be
// detached on deletion.
type MountRbd struct {
	FsType               string   `protobuf:"bytes,1,opt,name=fs_type,json=fsType,proto3" json:"fs_type,omitempty"`
	Id                   int64    `protobuf:"varint,2,opt,name=id,proto3" json:"id,omitempty"`
	MountOptions         []string `protobuf:"bytes,3,rep,name=mount_options,json=mountOptions,proto3" json:"mount_options,omitempty"`
	Mountpoint           string   `protobuf:"bytes,4,opt,name=mountpoint,proto3" json:"mountpoint,omitempty"`
	Rbd                  *Rbd     `protobuf:"bytes,5,opt,name=rbd,proto3" json:"rbd,omitempty"`
	RbdId                int64    `protobuf:"varint,6,opt,name=rbd_id,json=rbdId,proto3" json:"rbd_id,omitempty"`
	Refs                 int64    `protobuf:"varint,7,opt,name=refs,proto3" json:"refs,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MountRbd) Reset()         { *m = MountRbd{} }
func (m *MountRbd) String() string { return proto.CompactTextString(m) }
func (*MountRbd) ProtoMessage()    {}
func (*MountRbd) Descriptor() ([]byte, []int) {
	return fileDescriptor_e6ed858329eb171d, []int{5}
}
func (m *MountRbd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MountRbd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MountRbd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MountRbd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MountRbd.Merge(m, src)
}
func (m *MountRbd) XXX_Size() int {
	return m.Size()
}
func (m *MountRbd) XXX_DiscardUnknown() {
	xxx_messageInfo_MountRbd.DiscardUnknown(m)
}

var xxx_messageInfo_MountRbd proto.InternalMessageInfo

func (m *MountRbd) GetFsType() string {
	if m != nil {
		return m.FsType
	}
	return ""
}

func (m *MountRbd) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *MountRbd) GetMountOptions() []string {
	if m != nil {
		return m.MountOptions
	}
	return nil
}

func (m *MountRbd) GetMountpoint() string {
	if m != nil {
		return m.Mountpoint
	}
	return ""
}

func (m *MountRbd) GetRbd() *Rbd {
	if m != nil {
		return m.Rbd
	}
	return nil
}

func (m *MountRbd) GetRbdId() int64 {
	if m != nil {
		return m.RbdId
	}
	return 0
}

func (m *MountRbd) GetRefs() int64 {
	if m != nil {
		return m.Refs
	}
	return 0
}

func (*MountRbd) XXX_MessageName() string {
	return "ImageAPI.MountRbd"
}

// rbd describes an RBD map.  To successfully map, at least one monitor, pool and image must be specified.
// Additionally, you will need options.name and options.secret specified.
type Rbd struct {
	// The device_file is the path to the system device file.
	DeviceFile string `protobuf:"bytes,1,opt,name=device_file,json=deviceFile,proto3" json:"device_file,omitempty"`
	// The dev_id is the device ID in the rbd subsystem.
	DeviceId             int64       `protobuf:"varint,2,opt,name=device_id,json=deviceId,proto3" json:"device_id,omitempty"`
	Id                   int64       `protobuf:"varint,3,opt,name=id,proto3" json:"id,omitempty"`
	Image                string      `protobuf:"bytes,4,opt,name=image,proto3" json:"image,omitempty"`
	Monitors             []string    `protobuf:"bytes,5,rep,name=monitors,proto3" json:"monitors,omitempty"`
	Options              *RbdOptions `protobuf:"bytes,6,opt,name=options,proto3" json:"options,omitempty"`
	Pool                 string      `protobuf:"bytes,7,opt,name=pool,proto3" json:"pool,omitempty"`
	Refs                 int64       `protobuf:"varint,8,opt,name=refs,proto3" json:"refs,omitempty"`
	Snapshot             string      `protobuf:"bytes,9,opt,name=snapshot,proto3" json:"snapshot,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *Rbd) Reset()         { *m = Rbd{} }
func (m *Rbd) String() string { return proto.CompactTextString(m) }
func (*Rbd) ProtoMessage()    {}
func (*Rbd) Descriptor() ([]byte, []int) {
	return fileDescriptor_e6ed858329eb171d, []int{6}
}
func (m *Rbd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Rbd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Rbd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Rbd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Rbd.Merge(m, src)
}
func (m *Rbd) XXX_Size() int {
	return m.Size()
}
func (m *Rbd) XXX_DiscardUnknown() {
	xxx_messageInfo_Rbd.DiscardUnknown(m)
}

var xxx_messageInfo_Rbd proto.InternalMessageInfo

func (m *Rbd) GetDeviceFile() string {
	if m != nil {
		return m.DeviceFile
	}
	return ""
}

func (m *Rbd) GetDeviceId() int64 {
	if m != nil {
		return m.DeviceId
	}
	return 0
}

func (m *Rbd) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Rbd) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

func (m *Rbd) GetMonitors() []string {
	if m != nil {
		return m.Monitors
	}
	return nil
}

func (m *Rbd) GetOptions() *RbdOptions {
	if m != nil {
		return m.Options
	}
	return nil
}

func (m *Rbd) GetPool() string {
	if m != nil {
		return m.Pool
	}
	return ""
}

func (m *Rbd) GetRefs() int64 {
	if m != nil {
		return m.Refs
	}
	return 0
}

func (m *Rbd) GetSnapshot() string {
	if m != nil {
		return m.Snapshot
	}
	return ""
}

func (*Rbd) XXX_MessageName() string {
	return "ImageAPI.Rbd"
}

type RbdOptions struct {
	AbortOnFull              bool     `protobuf:"varint,1,opt,name=abort_on_full,json=abortOnFull,proto3" json:"abort_on_full,omitempty"`
	AllocSize                int32    `protobuf:"varint,2,opt,name=alloc_size,json=allocSize,proto3" json:"alloc_size,omitempty"`
	CephRequiresSignatures   bool     `protobuf:"varint,3,opt,name=ceph_requires_signatures,json=cephRequiresSignatures,proto3" json:"ceph_requires_signatures,omitempty"`
	CephxSignMessages        bool     `protobuf:"varint,4,opt,name=cephx_sign_messages,json=cephxSignMessages,proto3" json:"cephx_sign_messages,omitempty"`
	Crc                      bool     `protobuf:"varint,5,opt,name=crc,proto3" json:"crc,omitempty"`
	Exclusive                bool     `protobuf:"varint,6,opt,name=exclusive,proto3" json:"exclusive,omitempty"`
	Force                    bool     `protobuf:"varint,7,opt,name=force,proto3" json:"force,omitempty"`
	Fsid                     string   `protobuf:"bytes,8,opt,name=fsid,proto3" json:"fsid,omitempty"`
	Ip                       string   `protobuf:"bytes,9,opt,name=ip,proto3" json:"ip,omitempty"`
	LockOnRead               bool     `protobuf:"varint,10,opt,name=lock_on_read,json=lockOnRead,proto3" json:"lock_on_read,omitempty"`
	LockTimeout              int64    `protobuf:"varint,11,opt,name=lock_timeout,json=lockTimeout,proto3" json:"lock_timeout,omitempty"`
	MountTimeout             int32    `protobuf:"varint,12,opt,name=mount_timeout,json=mountTimeout,proto3" json:"mount_timeout,omitempty"`
	Name                     string   `protobuf:"bytes,13,opt,name=name,proto3" json:"name,omitempty"`
	Namespace                string   `protobuf:"bytes,14,opt,name=namespace,proto3" json:"namespace,omitempty"`
	NocephRequiresSignatures bool     `protobuf:"varint,15,opt,name=noceph_requires_signatures,json=nocephRequiresSignatures,proto3" json:"noceph_requires_signatures,omitempty"`
	NocephxSignMessages      bool     `protobuf:"varint,16,opt,name=nocephx_sign_messages,json=nocephxSignMessages,proto3" json:"nocephx_sign_messages,omitempty"`
	Nocrc                    bool     `protobuf:"varint,17,opt,name=nocrc,proto3" json:"nocrc,omitempty"`
	Noshare                  bool     `protobuf:"varint,18,opt,name=noshare,proto3" json:"noshare,omitempty"`
	NotcpNodelay             bool     `protobuf:"varint,19,opt,name=notcp_nodelay,json=notcpNodelay,proto3" json:"notcp_nodelay,omitempty"`
	Notrim                   bool     `protobuf:"varint,20,opt,name=notrim,proto3" json:"notrim,omitempty"`
	OsdIdleTtl               int32    `protobuf:"varint,21,opt,name=osd_idle_ttl,json=osdIdleTtl,proto3" json:"osd_idle_ttl,omitempty"`
	Osdkeepalive             int32    `protobuf:"varint,22,opt,name=osdkeepalive,proto3" json:"osdkeepalive,omitempty"`
	QueueDepth               int32    `protobuf:"varint,23,opt,name=queue_depth,json=queueDepth,proto3" json:"queue_depth,omitempty"`
	Ro                       bool     `protobuf:"varint,24,opt,name=ro,proto3" json:"ro,omitempty"`
	Rw                       bool     `protobuf:"varint,25,opt,name=rw,proto3" json:"rw,omitempty"`
	Secret                   string   `protobuf:"bytes,26,opt,name=secret,proto3" json:"secret,omitempty"`
	Share                    bool     `protobuf:"varint,27,opt,name=share,proto3" json:"share,omitempty"`
	TcpNodelay               bool     `protobuf:"varint,28,opt,name=tcp_nodelay,json=tcpNodelay,proto3" json:"tcp_nodelay,omitempty"`
	XXX_NoUnkeyedLiteral     struct{} `json:"-"`
	XXX_unrecognized         []byte   `json:"-"`
	XXX_sizecache            int32    `json:"-"`
}

func (m *RbdOptions) Reset()         { *m = RbdOptions{} }
func (m *RbdOptions) String() string { return proto.CompactTextString(m) }
func (*RbdOptions) ProtoMessage()    {}
func (*RbdOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_e6ed858329eb171d, []int{7}
}
func (m *RbdOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RbdOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RbdOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RbdOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RbdOptions.Merge(m, src)
}
func (m *RbdOptions) XXX_Size() int {
	return m.Size()
}
func (m *RbdOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_RbdOptions.DiscardUnknown(m)
}

var xxx_messageInfo_RbdOptions proto.InternalMessageInfo

func (m *RbdOptions) GetAbortOnFull() bool {
	if m != nil {
		return m.AbortOnFull
	}
	return false
}

func (m *RbdOptions) GetAllocSize() int32 {
	if m != nil {
		return m.AllocSize
	}
	return 0
}

func (m *RbdOptions) GetCephRequiresSignatures() bool {
	if m != nil {
		return m.CephRequiresSignatures
	}
	return false
}

func (m *RbdOptions) GetCephxSignMessages() bool {
	if m != nil {
		return m.CephxSignMessages
	}
	return false
}

func (m *RbdOptions) GetCrc() bool {
	if m != nil {
		return m.Crc
	}
	return false
}

func (m *RbdOptions) GetExclusive() bool {
	if m != nil {
		return m.Exclusive
	}
	return false
}

func (m *RbdOptions) GetForce() bool {
	if m != nil {
		return m.Force
	}
	return false
}

func (m *RbdOptions) GetFsid() string {
	if m != nil {
		return m.Fsid
	}
	return ""
}

func (m *RbdOptions) GetIp() string {
	if m != nil {
		return m.Ip
	}
	return ""
}

func (m *RbdOptions) GetLockOnRead() bool {
	if m != nil {
		return m.LockOnRead
	}
	return false
}

func (m *RbdOptions) GetLockTimeout() int64 {
	if m != nil {
		return m.LockTimeout
	}
	return 0
}

func (m *RbdOptions) GetMountTimeout() int32 {
	if m != nil {
		return m.MountTimeout
	}
	return 0
}

func (m *RbdOptions) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *RbdOptions) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *RbdOptions) GetNocephRequiresSignatures() bool {
	if m != nil {
		return m.NocephRequiresSignatures
	}
	return false
}

func (m *RbdOptions) GetNocephxSignMessages() bool {
	if m != nil {
		return m.NocephxSignMessages
	}
	return false
}

func (m *RbdOptions) GetNocrc() bool {
	if m != nil {
		return m.Nocrc
	}
	return false
}

func (m *RbdOptions) GetNoshare() bool {
	if m != nil {
		return m.Noshare
	}
	return false
}

func (m *RbdOptions) GetNotcpNodelay() bool {
	if m != nil {
		return m.NotcpNodelay
	}
	return false
}

func (m *RbdOptions) GetNotrim() bool {
	if m != nil {
		return m.Notrim
	}
	return false
}

func (m *RbdOptions) GetOsdIdleTtl() int32 {
	if m != nil {
		return m.OsdIdleTtl
	}
	return 0
}

func (m *RbdOptions) GetOsdkeepalive() int32 {
	if m != nil {
		return m.Osdkeepalive
	}
	return 0
}

func (m *RbdOptions) GetQueueDepth() int32 {
	if m != nil {
		return m.QueueDepth
	}
	return 0
}

func (m *RbdOptions) GetRo() bool {
	if m != nil {
		return m.Ro
	}
	return false
}

func (m *RbdOptions) GetRw() bool {
	if m != nil {
		return m.Rw
	}
	return false
}

func (m *RbdOptions) GetSecret() string {
	if m != nil {
		return m.Secret
	}
	return ""
}

func (m *RbdOptions) GetShare() bool {
	if m != nil {
		return m.Share
	}
	return false
}

func (m *RbdOptions) GetTcpNodelay() bool {
	if m != nil {
		return m.TcpNodelay
	}
	return false
}

func (*RbdOptions) XXX_MessageName() string {
	return "ImageAPI.RbdOptions"
}
func init() {
	proto.RegisterEnum("ImageAPI.ContainerNamespace", ContainerNamespace_name, ContainerNamespace_value)
	golang_proto.RegisterEnum("ImageAPI.ContainerNamespace", ContainerNamespace_name, ContainerNamespace_value)
	proto.RegisterEnum("ImageAPI.ContainerState", ContainerState_name, ContainerState_value)
	golang_proto.RegisterEnum("ImageAPI.ContainerState", ContainerState_name, ContainerState_value)
	proto.RegisterEnum("ImageAPI.Mount_MountKind", Mount_MountKind_name, Mount_MountKind_value)
	golang_proto.RegisterEnum("ImageAPI.Mount_MountKind", Mount_MountKind_name, Mount_MountKind_value)
	proto.RegisterType((*CustomType)(nil), "ImageAPI.CustomType")
	golang_proto.RegisterType((*CustomType)(nil), "ImageAPI.CustomType")
	proto.RegisterType((*Container)(nil), "ImageAPI.Container")
	golang_proto.RegisterType((*Container)(nil), "ImageAPI.Container")
	proto.RegisterType((*Error)(nil), "ImageAPI.Error")
	golang_proto.RegisterType((*Error)(nil), "ImageAPI.Error")
	proto.RegisterType((*Mount)(nil), "ImageAPI.Mount")
	golang_proto.RegisterType((*Mount)(nil), "ImageAPI.Mount")
	proto.RegisterType((*MountOverlay)(nil), "ImageAPI.MountOverlay")
	golang_proto.RegisterType((*MountOverlay)(nil), "ImageAPI.MountOverlay")
	proto.RegisterType((*MountRbd)(nil), "ImageAPI.MountRbd")
	golang_proto.RegisterType((*MountRbd)(nil), "ImageAPI.MountRbd")
	proto.RegisterType((*Rbd)(nil), "ImageAPI.Rbd")
	golang_proto.RegisterType((*Rbd)(nil), "ImageAPI.Rbd")
	proto.RegisterType((*RbdOptions)(nil), "ImageAPI.RbdOptions")
	golang_proto.RegisterType((*RbdOptions)(nil), "ImageAPI.RbdOptions")
}

func init() { proto.RegisterFile("generated.proto", fileDescriptor_e6ed858329eb171d) }
func init() { golang_proto.RegisterFile("generated.proto", fileDescriptor_e6ed858329eb171d) }

var fileDescriptor_e6ed858329eb171d = []byte{
	// 1285 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x74, 0x56, 0xcd, 0x6e, 0xdb, 0xc6,
	0x16, 0x0e, 0x45, 0xfd, 0x50, 0x47, 0xb6, 0xc2, 0x4c, 0x1c, 0x87, 0x71, 0x7c, 0x6d, 0x5d, 0xdd,
	0x1b, 0xc0, 0x08, 0x10, 0xb9, 0x70, 0x51, 0xb4, 0x40, 0xb3, 0xa8, 0x63, 0x29, 0x81, 0x90, 0x5a,
	0x32, 0x46, 0x72, 0xd1, 0x76, 0x43, 0x50, 0xe4, 0x48, 0x26, 0x4c, 0x71, 0x98, 0x19, 0x32, 0x8e,
	0x83, 0x3e, 0x45, 0x5f, 0xa4, 0xaf, 0xd0, 0x45, 0x17, 0x59, 0x76, 0xdd, 0x45, 0x51, 0x38, 0xaf,
	0xd0, 0x4d, 0x77, 0xc5, 0x9c, 0x21, 0x25, 0xd9, 0x49, 0x36, 0xf6, 0x7c, 0xe7, 0x9c, 0xf9, 0xf9,
	0xbe, 0xf3, 0x23, 0xc2, 0xed, 0x19, 0x8b, 0x99, 0xf0, 0x52, 0x16, 0x74, 0x12, 0xc1, 0x53, 0x4e,
	0xac, 0xfe, 0xdc, 0x9b, 0xb1, 0xc3, 0x93, 0xfe, 0xd6, 0x93, 0x59, 0x98, 0x9e, 0x65, 0x93, 0x8e,
	0xcf, 0xe7, 0xfb, 0x33, 0x3e, 0xe3, 0xfb, 0x18, 0x30, 0xc9, 0xa6, 0x88, 0x10, 0xe0, 0x4a, 0x6f,
	0x6c, 0xff, 0x04, 0x70, 0x94, 0xc9, 0x94, 0xcf, 0xc7, 0x97, 0x09, 0x23, 0x31, 0x54, 0x25, 0xf3,
	0x05, 0x4b, 0x1d, 0xa3, 0x65, 0xec, 0x35, 0x0e, 0x36, 0x3a, 0xc5, 0xb9, 0x1d, 0x3a, 0x09, 0x86,
	0x49, 0x1a, 0xf2, 0x58, 0x3e, 0xfb, 0xe6, 0x8f, 0x3f, 0x77, 0x9f, 0xae, 0x5c, 0x73, 0x96, 0xf8,
	0xfb, 0xe7, 0xc2, 0x3b, 0x67, 0xf1, 0x3e, 0x7b, 0x93, 0xb2, 0x58, 0xaa, 0xa8, 0xfd, 0x50, 0xed,
	0xf4, 0x92, 0x70, 0xdf, 0xc7, 0xf3, 0xd3, 0xcb, 0x84, 0xc9, 0xce, 0x08, 0x4f, 0xa7, 0xf9, 0x2d,
	0xed, 0x9f, 0x4b, 0x50, 0x3f, 0xe2, 0x71, 0xea, 0x85, 0x31, 0x13, 0xc4, 0x81, 0x9a, 0xcf, 0xe7,
	0x73, 0x2f, 0x0e, 0xf0, 0xfa, 0x3a, 0x2d, 0x20, 0x69, 0x42, 0x29, 0x0c, 0x9c, 0x52, 0xcb, 0xd8,
	0x33, 0x69, 0x29, 0x0c, 0x54, 0x64, 0xc4, 0x67, 0xd3, 0x30, 0x62, 0x8e, 0xa9, 0x23, 0x73, 0x48,
	0x1e, 0x41, 0x65, 0xce, 0xb3, 0x38, 0x75, 0xca, 0x48, 0xe0, 0xf6, 0x92, 0xc0, 0xb1, 0x32, 0x53,
	0xed, 0x25, 0x04, 0xca, 0xb1, 0x37, 0x67, 0x4e, 0x05, 0x77, 0xe3, 0x9a, 0x3c, 0x05, 0x50, 0xff,
	0x65, 0xe2, 0xf9, 0x4c, 0x3a, 0xd5, 0x96, 0xb9, 0xd7, 0x3c, 0xd8, 0x5e, 0xee, 0x5f, 0xbc, 0x73,
	0x50, 0x04, 0xd1, 0x95, 0x78, 0xd2, 0x81, 0x8a, 0x4c, 0xbd, 0x94, 0x39, 0xb5, 0x96, 0xb1, 0xd7,
	0x3c, 0x70, 0x3e, 0xb2, 0x71, 0xa4, 0xfc, 0x54, 0x87, 0x29, 0x0a, 0xf2, 0x52, 0xa6, 0x6c, 0x1e,
	0x38, 0x56, 0xcb, 0xd8, 0xb3, 0x68, 0x01, 0xdb, 0x5f, 0x40, 0xa5, 0x27, 0x04, 0x17, 0xea, 0x91,
	0x3e, 0x0f, 0x18, 0x8a, 0x61, 0x52, 0x5c, 0xab, 0x6d, 0x73, 0x26, 0xa5, 0x37, 0x63, 0x28, 0x47,
	0x9d, 0x16, 0xb0, 0x7d, 0x65, 0x40, 0x05, 0x39, 0x92, 0x27, 0x50, 0x3e, 0x0f, 0x73, 0x11, 0x9b,
	0x07, 0x0f, 0x6e, 0x48, 0xa0, 0xff, 0xbe, 0x0c, 0xe3, 0x80, 0x62, 0x18, 0x79, 0x00, 0x16, 0x8a,
	0xe2, 0x2e, 0x24, 0xae, 0x21, 0xee, 0x07, 0xe4, 0x33, 0xa8, 0xf1, 0xd7, 0x4c, 0x44, 0xde, 0x25,
	0xea, 0xdc, 0x38, 0xd8, 0xbc, 0x71, 0xd8, 0x50, 0x7b, 0x69, 0x11, 0x46, 0xfe, 0x0f, 0xa6, 0x98,
	0x04, 0xb9, 0xfa, 0xe4, 0xa6, 0xfa, 0x93, 0x80, 0x2a, 0x77, 0xfb, 0x4b, 0xa8, 0x2f, 0x5e, 0x41,
	0x36, 0x81, 0x1c, 0x0f, 0x4f, 0x07, 0x63, 0xf7, 0x65, 0x7f, 0xd0, 0x75, 0x87, 0xdf, 0xf5, 0xe8,
	0xb7, 0x87, 0x3f, 0xd8, 0xb7, 0x08, 0x81, 0xe6, 0x8a, 0x9d, 0x3e, 0xeb, 0xda, 0x46, 0xfb, 0x17,
	0x03, 0xd6, 0x56, 0x2f, 0xce, 0x2b, 0xc3, 0x58, 0x54, 0xc6, 0x23, 0xa8, 0x44, 0xfc, 0x82, 0x09,
	0xa7, 0xd4, 0x32, 0x3f, 0x9a, 0x7f, 0xf4, 0x92, 0x1d, 0x00, 0xe4, 0x98, 0xf0, 0x30, 0x4e, 0xf3,
	0x1a, 0x5a, 0xb1, 0x28, 0xe9, 0x05, 0x9b, 0x4a, 0xe4, 0x61, 0x52, 0x5c, 0x93, 0x2d, 0xb0, 0xb2,
	0x24, 0x61, 0x22, 0x08, 0x45, 0x5e, 0x37, 0x0b, 0xac, 0xd2, 0x72, 0xc1, 0xc5, 0xb9, 0x72, 0x55,
	0x75, 0x5a, 0x72, 0xd8, 0xfe, 0xcd, 0x00, 0xab, 0x20, 0x4f, 0xee, 0x43, 0x6d, 0x2a, 0x5d, 0xd5,
	0x0a, 0x79, 0x85, 0x57, 0xa7, 0x12, 0x1b, 0xef, 0x66, 0x81, 0xff, 0x0f, 0xd6, 0x75, 0x4e, 0xb8,
	0xee, 0x39, 0xc7, 0x6c, 0x99, 0x7b, 0x75, 0xba, 0x86, 0xc6, 0xbc, 0x0f, 0x6f, 0x90, 0x28, 0x7f,
	0x40, 0x62, 0x57, 0xe7, 0xa2, 0x82, 0xb9, 0x58, 0xbf, 0xd6, 0xca, 0x98, 0x06, 0x72, 0x0f, 0xaa,
	0x62, 0x12, 0xa8, 0xbc, 0x57, 0xf1, 0xe6, 0x8a, 0x98, 0x04, 0xfd, 0x60, 0x41, 0xbe, 0xb6, 0x24,
	0xdf, 0xfe, 0xc7, 0x00, 0x53, 0x31, 0xd8, 0x85, 0x46, 0xc0, 0x5e, 0x87, 0x3e, 0x73, 0xb1, 0xfb,
	0x34, 0x0b, 0xd0, 0xa6, 0xe7, 0xaa, 0x01, 0x1f, 0x42, 0x3d, 0x0f, 0x58, 0x10, 0xb2, 0xb4, 0xa1,
	0x5f, 0xf4, 0xb1, 0xb9, 0xa0, 0xb9, 0x01, 0x15, 0x1c, 0x13, 0xf9, 0xe3, 0x35, 0x50, 0x42, 0xcf,
	0x79, 0x1c, 0xa6, 0x5c, 0x48, 0xa7, 0x82, 0xbc, 0x17, 0x98, 0x74, 0xa0, 0x56, 0x48, 0x52, 0xfd,
	0xf4, 0x88, 0xa2, 0x45, 0x90, 0xe2, 0x92, 0x70, 0x1e, 0x21, 0x97, 0x3a, 0xc5, 0xf5, 0x82, 0x9f,
	0x75, 0x3d, 0xb9, 0x32, 0xf6, 0x12, 0x79, 0xc6, 0x53, 0xa7, 0xae, 0x93, 0x5b, 0xe0, 0xf6, 0xdf,
	0x55, 0x80, 0xe5, 0xd9, 0xa4, 0x0d, 0xeb, 0xde, 0x84, 0x8b, 0xd4, 0xe5, 0xb1, 0x3b, 0xcd, 0xa2,
	0x08, 0x45, 0xb0, 0x68, 0x03, 0x8d, 0xc3, 0xf8, 0x79, 0x16, 0x45, 0xe4, 0x3f, 0x00, 0x5e, 0x14,
	0x71, 0xdf, 0x95, 0xe1, 0x5b, 0xdd, 0xa9, 0x15, 0x5a, 0x47, 0xcb, 0x28, 0x7c, 0xcb, 0xc8, 0x57,
	0xe0, 0xf8, 0x2c, 0x39, 0x73, 0x05, 0x7b, 0x95, 0x85, 0x82, 0x49, 0x57, 0x86, 0xb3, 0xd8, 0x4b,
	0x33, 0xc1, 0x24, 0xaa, 0x63, 0xd1, 0x4d, 0xe5, 0xa7, 0xb9, 0x7b, 0xb4, 0xf0, 0x92, 0x0e, 0xdc,
	0x55, 0x9e, 0x37, 0xb8, 0xc3, 0xcd, 0x7b, 0x5f, 0xd7, 0xa9, 0x45, 0xef, 0xa0, 0x4b, 0x45, 0x1f,
	0xe7, 0x0e, 0x62, 0x83, 0xe9, 0x0b, 0x1f, 0x6b, 0xc0, 0xa2, 0x6a, 0x49, 0xb6, 0xa1, 0xce, 0xde,
	0xf8, 0x51, 0x26, 0xc3, 0xd7, 0x0c, 0x35, 0xb4, 0xe8, 0xd2, 0xa0, 0x32, 0x32, 0xe5, 0xc2, 0xd7,
	0x63, 0xcc, 0xa2, 0x1a, 0x28, 0xc5, 0xa6, 0x32, 0xd4, 0x93, 0xaa, 0x4e, 0x71, 0x8d, 0xb9, 0x4c,
	0x72, 0xad, 0x4a, 0x61, 0x42, 0x5a, 0xb0, 0x16, 0x71, 0xff, 0x5c, 0xa9, 0x22, 0x98, 0x17, 0x38,
	0x80, 0x07, 0x80, 0xb2, 0x0d, 0x63, 0xca, 0xbc, 0x80, 0xfc, 0x37, 0x8f, 0x48, 0xc3, 0x39, 0xe3,
	0x59, 0xea, 0x34, 0x50, 0xff, 0x86, 0xb2, 0x8d, 0xb5, 0x69, 0x59, 0xf7, 0x45, 0xcc, 0x1a, 0x4a,
	0xa7, 0xeb, 0xbe, 0x08, 0x2a, 0x86, 0xf7, 0xfa, 0xca, 0xf0, 0xde, 0x86, 0xfa, 0x62, 0x18, 0x3b,
	0x4d, 0x74, 0x2c, 0x0d, 0xe4, 0x29, 0x6c, 0xc5, 0xfc, 0x93, 0x8a, 0xdf, 0xc6, 0x97, 0x3a, 0x3a,
	0xe2, 0x23, 0x9a, 0x1f, 0xc0, 0x3d, 0xed, 0xbb, 0xa9, 0xba, 0x8d, 0x1b, 0xef, 0xe6, 0xce, 0x6b,
	0xba, 0x6f, 0x40, 0x25, 0xe6, 0x4a, 0xf9, 0x3b, 0x5a, 0x47, 0x04, 0x6a, 0x4c, 0xc4, 0x5c, 0x9e,
	0x79, 0x82, 0x39, 0x44, 0x0f, 0xfd, 0x1c, 0x2a, 0xe2, 0x31, 0x4f, 0xfd, 0xc4, 0x8d, 0x79, 0xc0,
	0xd4, 0xbc, 0xbd, 0x8b, 0xfe, 0x35, 0x34, 0x0e, 0xb4, 0x8d, 0x6c, 0x42, 0x35, 0xe6, 0xa9, 0x08,
	0xe7, 0xce, 0x06, 0x7a, 0x73, 0xa4, 0xa4, 0xe7, 0x52, 0xf5, 0x71, 0xc4, 0xdc, 0x34, 0x8d, 0x9c,
	0x7b, 0x28, 0x1a, 0x70, 0x19, 0xf4, 0x83, 0x88, 0x8d, 0xd3, 0x88, 0xb4, 0x31, 0xe2, 0x9c, 0xb1,
	0xc4, 0x8b, 0x54, 0xde, 0x37, 0xb5, 0xac, 0xab, 0x36, 0xd5, 0xda, 0xaf, 0x32, 0x96, 0x31, 0x37,
	0x60, 0x49, 0x7a, 0xe6, 0xdc, 0xd7, 0x87, 0xa0, 0xa9, 0xab, 0x2c, 0x2a, 0xe3, 0x82, 0x3b, 0x0e,
	0x5e, 0x5d, 0x12, 0x1c, 0xf1, 0x85, 0xf3, 0x20, 0xc7, 0x17, 0xea, 0x79, 0xf9, 0xd7, 0xc3, 0x96,
	0x1e, 0x6e, 0x1a, 0x29, 0x2d, 0x34, 0xe7, 0x87, 0x5a, 0x0b, 0xcd, 0x78, 0x17, 0x1a, 0xab, 0x7c,
	0xb7, 0x75, 0xb9, 0x2c, 0xd9, 0x3e, 0xf6, 0x80, 0x7c, 0xf8, 0x9b, 0x4b, 0x00, 0xaa, 0x47, 0x2f,
	0xe8, 0xf0, 0xf4, 0xc4, 0xbe, 0x45, 0x6a, 0x60, 0xf6, 0x4f, 0x8e, 0x6c, 0x43, 0x2d, 0x06, 0xbd,
	0xb1, 0x5d, 0x52, 0x8b, 0xe3, 0xc1, 0xd8, 0x36, 0xd5, 0xe2, 0xa4, 0xdf, 0xb5, 0xcb, 0xc4, 0x82,
	0xf2, 0xb8, 0x7f, 0xdc, 0xb3, 0x2b, 0x6a, 0x75, 0x3a, 0xea, 0x51, 0xbb, 0xaa, 0x9c, 0xa7, 0xe3,
	0x91, 0x5d, 0x7b, 0x3c, 0x80, 0xe6, 0xf5, 0x5f, 0x67, 0xd2, 0x80, 0xda, 0x11, 0xed, 0x1d, 0x8e,
	0x7b, 0x5d, 0xfb, 0x96, 0x02, 0xf4, 0x74, 0x30, 0xe8, 0x0f, 0x5e, 0xd8, 0x06, 0x59, 0x03, 0x6b,
	0x34, 0x1e, 0x9e, 0x9c, 0x28, 0x54, 0x52, 0xcf, 0xe8, 0x7d, 0xdf, 0x57, 0x61, 0xa6, 0x3a, 0xb8,
	0xdb, 0x3b, 0xec, 0xda, 0xe5, 0x67, 0xad, 0x77, 0x57, 0x3b, 0xc6, 0xef, 0x57, 0x3b, 0xc6, 0x5f,
	0x57, 0x3b, 0xc6, 0xaf, 0xef, 0x77, 0x8c, 0x77, 0xef, 0x77, 0x8c, 0x1f, 0xa1, 0xf3, 0x75, 0xf1,
	0x31, 0x34, 0xa9, 0xe2, 0x67, 0xd7, 0xe7, 0xff, 0x06, 0x00, 0x00, 0xff, 0xff, 0x73, 0x10, 0x37,
	0x99, 0xc2, 0x09, 0x00, 0x00,
}

func (m *CustomType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CustomType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CustomType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Secret != nil {
		{
			size := m.Secret.Size()
			i -= size
			if _, err := m.Secret.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Container) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Container) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Container) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Systemd {
		i--
		if m.Systemd {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.State != 0 {
		i = encodeVarintGenerated(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Namespaces) > 0 {
		dAtA3 := make([]byte, len(m.Namespaces)*10)
		var j2 int
		for _, num := range m.Namespaces {
			for num >= 1<<7 {
				dAtA3[j2] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j2++
			}
			dAtA3[j2] = uint8(num)
			j2++
		}
		i -= j2
		copy(dAtA[i:], dAtA3[:j2])
		i = encodeVarintGenerated(dAtA, i, uint64(j2))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintGenerated(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Mount != nil {
		{
			size, err := m.Mount.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Logfile) > 0 {
		i -= len(m.Logfile)
		copy(dAtA[i:], m.Logfile)
		i = encodeVarintGenerated(dAtA, i, uint64(len(m.Logfile)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Id != 0 {
		i = encodeVarintGenerated(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Command) > 0 {
		i -= len(m.Command)
		copy(dAtA[i:], m.Command)
		i = encodeVarintGenerated(dAtA, i, uint64(len(m.Command)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Error) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Error) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Error) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintGenerated(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintGenerated(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Mount) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Mount) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Mount) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Rbd != nil {
		{
			size, err := m.Rbd.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Overlay != nil {
		{
			size, err := m.Overlay.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.MountId != 0 {
		i = encodeVarintGenerated(dAtA, i, uint64(m.MountId))
		i--
		dAtA[i] = 0x10
	}
	if m.Kind != 0 {
		i = encodeVarintGenerated(dAtA, i, uint64(m.Kind))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MountOverlay) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MountOverlay) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MountOverlay) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Workdir) > 0 {
		i -= len(m.Workdir)
		copy(dAtA[i:], m.Workdir)
		i = encodeVarintGenerated(dAtA, i, uint64(len(m.Workdir)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Upperdir) > 0 {
		i -= len(m.Upperdir)
		copy(dAtA[i:], m.Upperdir)
		i = encodeVarintGenerated(dAtA, i, uint64(len(m.Upperdir)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Refs != 0 {
		i = encodeVarintGenerated(dAtA, i, uint64(m.Refs))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Mountpoint) > 0 {
		i -= len(m.Mountpoint)
		copy(dAtA[i:], m.Mountpoint)
		i = encodeVarintGenerated(dAtA, i, uint64(len(m.Mountpoint)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Lower) > 0 {
		for iNdEx := len(m.Lower) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Lower[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Id != 0 {
		i = encodeVarintGenerated(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MountRbd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MountRbd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MountRbd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Refs != 0 {
		i = encodeVarintGenerated(dAtA, i, uint64(m.Refs))
		i--
		dAtA[i] = 0x38
	}
	if m.RbdId != 0 {
		i = encodeVarintGenerated(dAtA, i, uint64(m.RbdId))
		i--
		dAtA[i] = 0x30
	}
	if m.Rbd != nil {
		{
			size, err := m.Rbd.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Mountpoint) > 0 {
		i -= len(m.Mountpoint)
		copy(dAtA[i:], m.Mountpoint)
		i = encodeVarintGenerated(dAtA, i, uint64(len(m.Mountpoint)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.MountOptions) > 0 {
		for iNdEx := len(m.MountOptions) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.MountOptions[iNdEx])
			copy(dAtA[i:], m.MountOptions[iNdEx])
			i = encodeVarintGenerated(dAtA, i, uint64(len(m.MountOptions[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Id != 0 {
		i = encodeVarintGenerated(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x10
	}
	if len(m.FsType) > 0 {
		i -= len(m.FsType)
		copy(dAtA[i:], m.FsType)
		i = encodeVarintGenerated(dAtA, i, uint64(len(m.FsType)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Rbd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Rbd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Rbd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Snapshot) > 0 {
		i -= len(m.Snapshot)
		copy(dAtA[i:], m.Snapshot)
		i = encodeVarintGenerated(dAtA, i, uint64(len(m.Snapshot)))
		i--
		dAtA[i] = 0x4a
	}
	if m.Refs != 0 {
		i = encodeVarintGenerated(dAtA, i, uint64(m.Refs))
		i--
		dAtA[i] = 0x40
	}
	if len(m.Pool) > 0 {
		i -= len(m.Pool)
		copy(dAtA[i:], m.Pool)
		i = encodeVarintGenerated(dAtA, i, uint64(len(m.Pool)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Options != nil {
		{
			size, err := m.Options.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.Monitors) > 0 {
		for iNdEx := len(m.Monitors) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Monitors[iNdEx])
			copy(dAtA[i:], m.Monitors[iNdEx])
			i = encodeVarintGenerated(dAtA, i, uint64(len(m.Monitors[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Image) > 0 {
		i -= len(m.Image)
		copy(dAtA[i:], m.Image)
		i = encodeVarintGenerated(dAtA, i, uint64(len(m.Image)))
		i--
		dAtA[i] = 0x22
	}
	if m.Id != 0 {
		i = encodeVarintGenerated(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x18
	}
	if m.DeviceId != 0 {
		i = encodeVarintGenerated(dAtA, i, uint64(m.DeviceId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.DeviceFile) > 0 {
		i -= len(m.DeviceFile)
		copy(dAtA[i:], m.DeviceFile)
		i = encodeVarintGenerated(dAtA, i, uint64(len(m.DeviceFile)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RbdOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RbdOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RbdOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TcpNodelay {
		i--
		if m.TcpNodelay {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe0
	}
	if m.Share {
		i--
		if m.Share {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd8
	}
	if len(m.Secret) > 0 {
		i -= len(m.Secret)
		copy(dAtA[i:], m.Secret)
		i = encodeVarintGenerated(dAtA, i, uint64(len(m.Secret)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd2
	}
	if m.Rw {
		i--
		if m.Rw {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc8
	}
	if m.Ro {
		i--
		if m.Ro {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc0
	}
	if m.QueueDepth != 0 {
		i = encodeVarintGenerated(dAtA, i, uint64(m.QueueDepth))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if m.Osdkeepalive != 0 {
		i = encodeVarintGenerated(dAtA, i, uint64(m.Osdkeepalive))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.OsdIdleTtl != 0 {
		i = encodeVarintGenerated(dAtA, i, uint64(m.OsdIdleTtl))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.Notrim {
		i--
		if m.Notrim {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.NotcpNodelay {
		i--
		if m.NotcpNodelay {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.Noshare {
		i--
		if m.Noshare {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.Nocrc {
		i--
		if m.Nocrc {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.NocephxSignMessages {
		i--
		if m.NocephxSignMessages {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.NocephRequiresSignatures {
		i--
		if m.NocephRequiresSignatures {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x78
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintGenerated(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintGenerated(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x6a
	}
	if m.MountTimeout != 0 {
		i = encodeVarintGenerated(dAtA, i, uint64(m.MountTimeout))
		i--
		dAtA[i] = 0x60
	}
	if m.LockTimeout != 0 {
		i = encodeVarintGenerated(dAtA, i, uint64(m.LockTimeout))
		i--
		dAtA[i] = 0x58
	}
	if m.LockOnRead {
		i--
		if m.LockOnRead {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if len(m.Ip) > 0 {
		i -= len(m.Ip)
		copy(dAtA[i:], m.Ip)
		i = encodeVarintGenerated(dAtA, i, uint64(len(m.Ip)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Fsid) > 0 {
		i -= len(m.Fsid)
		copy(dAtA[i:], m.Fsid)
		i = encodeVarintGenerated(dAtA, i, uint64(len(m.Fsid)))
		i--
		dAtA[i] = 0x42
	}
	if m.Force {
		i--
		if m.Force {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.Exclusive {
		i--
		if m.Exclusive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.Crc {
		i--
		if m.Crc {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.CephxSignMessages {
		i--
		if m.CephxSignMessages {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.CephRequiresSignatures {
		i--
		if m.CephRequiresSignatures {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.AllocSize != 0 {
		i = encodeVarintGenerated(dAtA, i, uint64(m.AllocSize))
		i--
		dAtA[i] = 0x10
	}
	if m.AbortOnFull {
		i--
		if m.AbortOnFull {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintGenerated(dAtA []byte, offset int, v uint64) int {
	offset -= sovGenerated(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *CustomType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Secret != nil {
		l = m.Secret.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Container) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Command)
	if l > 0 {
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Id != 0 {
		n += 1 + sovGenerated(uint64(m.Id))
	}
	l = len(m.Logfile)
	if l > 0 {
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Mount != nil {
		l = m.Mount.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovGenerated(uint64(l))
	}
	if len(m.Namespaces) > 0 {
		l = 0
		for _, e := range m.Namespaces {
			l += sovGenerated(uint64(e))
		}
		n += 1 + sovGenerated(uint64(l)) + l
	}
	if m.State != 0 {
		n += 1 + sovGenerated(uint64(m.State))
	}
	if m.Systemd {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Error) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovGenerated(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Mount) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Kind != 0 {
		n += 1 + sovGenerated(uint64(m.Kind))
	}
	if m.MountId != 0 {
		n += 1 + sovGenerated(uint64(m.MountId))
	}
	if m.Overlay != nil {
		l = m.Overlay.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Rbd != nil {
		l = m.Rbd.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MountOverlay) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovGenerated(uint64(m.Id))
	}
	if len(m.Lower) > 0 {
		for _, e := range m.Lower {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	l = len(m.Mountpoint)
	if l > 0 {
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Refs != 0 {
		n += 1 + sovGenerated(uint64(m.Refs))
	}
	l = len(m.Upperdir)
	if l > 0 {
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = len(m.Workdir)
	if l > 0 {
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MountRbd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FsType)
	if l > 0 {
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Id != 0 {
		n += 1 + sovGenerated(uint64(m.Id))
	}
	if len(m.MountOptions) > 0 {
		for _, s := range m.MountOptions {
			l = len(s)
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	l = len(m.Mountpoint)
	if l > 0 {
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Rbd != nil {
		l = m.Rbd.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.RbdId != 0 {
		n += 1 + sovGenerated(uint64(m.RbdId))
	}
	if m.Refs != 0 {
		n += 1 + sovGenerated(uint64(m.Refs))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Rbd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DeviceFile)
	if l > 0 {
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.DeviceId != 0 {
		n += 1 + sovGenerated(uint64(m.DeviceId))
	}
	if m.Id != 0 {
		n += 1 + sovGenerated(uint64(m.Id))
	}
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovGenerated(uint64(l))
	}
	if len(m.Monitors) > 0 {
		for _, s := range m.Monitors {
			l = len(s)
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if m.Options != nil {
		l = m.Options.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = len(m.Pool)
	if l > 0 {
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Refs != 0 {
		n += 1 + sovGenerated(uint64(m.Refs))
	}
	l = len(m.Snapshot)
	if l > 0 {
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RbdOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AbortOnFull {
		n += 2
	}
	if m.AllocSize != 0 {
		n += 1 + sovGenerated(uint64(m.AllocSize))
	}
	if m.CephRequiresSignatures {
		n += 2
	}
	if m.CephxSignMessages {
		n += 2
	}
	if m.Crc {
		n += 2
	}
	if m.Exclusive {
		n += 2
	}
	if m.Force {
		n += 2
	}
	l = len(m.Fsid)
	if l > 0 {
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = len(m.Ip)
	if l > 0 {
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.LockOnRead {
		n += 2
	}
	if m.LockTimeout != 0 {
		n += 1 + sovGenerated(uint64(m.LockTimeout))
	}
	if m.MountTimeout != 0 {
		n += 1 + sovGenerated(uint64(m.MountTimeout))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.NocephRequiresSignatures {
		n += 2
	}
	if m.NocephxSignMessages {
		n += 3
	}
	if m.Nocrc {
		n += 3
	}
	if m.Noshare {
		n += 3
	}
	if m.NotcpNodelay {
		n += 3
	}
	if m.Notrim {
		n += 3
	}
	if m.OsdIdleTtl != 0 {
		n += 2 + sovGenerated(uint64(m.OsdIdleTtl))
	}
	if m.Osdkeepalive != 0 {
		n += 2 + sovGenerated(uint64(m.Osdkeepalive))
	}
	if m.QueueDepth != 0 {
		n += 2 + sovGenerated(uint64(m.QueueDepth))
	}
	if m.Ro {
		n += 3
	}
	if m.Rw {
		n += 3
	}
	l = len(m.Secret)
	if l > 0 {
		n += 2 + l + sovGenerated(uint64(l))
	}
	if m.Share {
		n += 3
	}
	if m.TcpNodelay {
		n += 3
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovGenerated(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozGenerated(x uint64) (n int) {
	return sovGenerated(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CustomType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CustomType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CustomType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Secret", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Secret == nil {
				m.Secret = &github_com_hpc_kraken_extensions_imageapi_customtypes.Secret{}
			}
			if err := m.Secret.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Container) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Container: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Container: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Command = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Logfile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Logfile = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mount == nil {
				m.Mount = &Mount{}
			}
			if err := m.Mount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType == 0 {
				var v ContainerNamespace
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGenerated
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= ContainerNamespace(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Namespaces = append(m.Namespaces, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGenerated
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthGenerated
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthGenerated
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Namespaces) == 0 {
					m.Namespaces = make([]ContainerNamespace, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v ContainerNamespace
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGenerated
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= ContainerNamespace(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Namespaces = append(m.Namespaces, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespaces", wireType)
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= ContainerState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Systemd", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Systemd = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Error) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Error: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Error: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Mount) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Mount: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Mount: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= Mount_MountKind(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MountId", wireType)
			}
			m.MountId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MountId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Overlay", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Overlay == nil {
				m.Overlay = &MountOverlay{}
			}
			if err := m.Overlay.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rbd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rbd == nil {
				m.Rbd = &MountRbd{}
			}
			if err := m.Rbd.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MountOverlay) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MountOverlay: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MountOverlay: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lower", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Lower = append(m.Lower, &Mount{})
			if err := m.Lower[len(m.Lower)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mountpoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mountpoint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Refs", wireType)
			}
			m.Refs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Refs |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Upperdir", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Upperdir = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Workdir", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Workdir = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MountRbd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MountRbd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MountRbd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FsType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FsType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MountOptions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MountOptions = append(m.MountOptions, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mountpoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mountpoint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rbd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rbd == nil {
				m.Rbd = &Rbd{}
			}
			if err := m.Rbd.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RbdId", wireType)
			}
			m.RbdId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RbdId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Refs", wireType)
			}
			m.Refs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Refs |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Rbd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Rbd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Rbd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceFile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceFile = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceId", wireType)
			}
			m.DeviceId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeviceId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Monitors", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Monitors = append(m.Monitors, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &RbdOptions{}
			}
			if err := m.Options.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pool", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pool = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Refs", wireType)
			}
			m.Refs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Refs |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Snapshot", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Snapshot = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RbdOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RbdOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RbdOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AbortOnFull", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AbortOnFull = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllocSize", wireType)
			}
			m.AllocSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AllocSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CephRequiresSignatures", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CephRequiresSignatures = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CephxSignMessages", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CephxSignMessages = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crc", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Crc = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exclusive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Exclusive = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Force", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Force = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fsid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fsid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockOnRead", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LockOnRead = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockTimeout", wireType)
			}
			m.LockTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LockTimeout |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MountTimeout", wireType)
			}
			m.MountTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MountTimeout |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NocephRequiresSignatures", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NocephRequiresSignatures = bool(v != 0)
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NocephxSignMessages", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NocephxSignMessages = bool(v != 0)
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nocrc", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Nocrc = bool(v != 0)
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Noshare", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Noshare = bool(v != 0)
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotcpNodelay", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NotcpNodelay = bool(v != 0)
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Notrim", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Notrim = bool(v != 0)
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OsdIdleTtl", wireType)
			}
			m.OsdIdleTtl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OsdIdleTtl |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Osdkeepalive", wireType)
			}
			m.Osdkeepalive = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Osdkeepalive |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueueDepth", wireType)
			}
			m.QueueDepth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QueueDepth |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ro", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ro = bool(v != 0)
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rw", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Rw = bool(v != 0)
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Secret", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Secret = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Share", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Share = bool(v != 0)
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpNodelay", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TcpNodelay = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipGenerated(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthGenerated
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupGenerated
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthGenerated
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthGenerated        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowGenerated          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupGenerated = fmt.Errorf("proto: unexpected end of group")
)
