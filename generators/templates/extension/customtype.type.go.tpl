// One-time generated by kraken {{ .Global.Version }}.
// You probably want to edit this file to add values you need.
// `kraken extension update` *will not* replace this file.
// `kraken -f extension generate` *will* replace this file.

// The generated template is supposed to act more as an example than something useable out-of-the-box
// You'll probably need to update most of these methods to make something functional.

package customtypes

import (
	"strconv"
	"strings"

	"github.com/kraken-hpc/kraken/lib/types"
)

var _ (types.ExtensionCustomType) = {{ .Name }}{}
var _ (types.ExtensionCustomTypePtr) = (*{{ .Name }})(nil)

type {{ .Name }} struct {
	// TODO: you might want this type to be based on some other kind of data
	//       if you change this, all of the methods will need to change appropriately
	s string
}

// Marshal controls how the type is converted to binary
func (t {{ .Name }}) Marshal() ([]byte, error) {
	return []byte(t.s), nil
}

// MarshalTo is like Marshal, but writes the result to `data`
func (t *{{ .Name }}) MarshalTo(data []byte) (int, error) {
	copy(data, []byte(t.s))
	return len(t.s), nil
}

// Unmarshal converts an encoded []byte to populate the type
func (t *{{ .Name }}) Unmarshal(data []byte) error {
	t.s = string(data)
	return nil
}

// Size returns the size (encoded) of the type
func (t *{{ .Name }}) Size() int {
	return len(t.s)
}

// MarshalJSON writes the type to JSON format in the form of a byte string
func (t {{ .Name }}) MarshalJSON() (j []byte, e error) {
	return []byte(strconv.Quote(t.s)), nil
}

// UnmarshalJSON takes byte string JSON to populate the type
func (t *{{ .Name }}) UnmarshalJSON(data []byte) error {
	t.s = strings.Trim(string(data), "\"'")
	return nil
}
