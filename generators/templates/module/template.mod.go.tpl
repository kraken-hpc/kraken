// Generated by kraken {{- .Global.Version }}. DO NOT EDIT
// To update, run `kraken module update`

package {{ .PackageName }}

import (
	"reflect"

	{{- if .WithConfig }}
	ptypes "github.com/gogo/protobuf/types"
	{{ end }}
	"github.com/kraken-hpc/kraken/core"
	cpb "github.com/kraken-hpc/kraken/core/proto"
	"github.com/kraken-hpc/kraken/lib/types"
	"github.com/kraken-hpc/kraken/lib/util"
)

///////////////////////
// Global Variables //
/////////////////////

var api types.ModuleAPIClient              // the ModuleAPI client
var self types.NodeID                      // our own node ID
var si types.ServiceInstance               // our own service instance
var mchan <-chan types.Event               // mutation event channel (recieve)
var dchan chan<- types.Event               // discovery event channel (send)
var interruptHandler = hInterruptUnhandled // set this in order to process mutation interrupts

///////////////////////////
// Mutation Definitions //
/////////////////////////

var mutations = map[string]*core.Mutation{
	{{- range $name, $mutation := .Mutations }}
	"{{- $name }}": {
		Mutates: map[string][2]string{
			{{- range $url, $values := $mutation.Mutates }}
			"{{- $url }}": {"{{- $values.From }}", "{{- $values.To }}"},
			{{- end }}
		},
		Requires: map[string]string{
			{{- range $url, $value := $mutation.Requires }}
			"{{- $url }}": "{{- $value }}",
			{{- end }}
		},
		Excludes: map[string]string{
			{{- range $url, $value := $mutation.Excludes }}
			"{{- $url }}": "{{- $value }}",
			{{- end }}
		},
		Context: "{{- $mutation.Context }}",
		Timeout: "{{- $mutation.Timeout }}",
		FailTo:  [2]string{"{{- $mutation.FailTo.Url }}", "{{- $mutation.FailTo.Value }}"},
	},
	{{- end }}
}

////////////////////////////
// Discovery Definitions //
//////////////////////////

// Note: Discoveries that are implicit by mutations are automatically included
//       Discoveries for the service state are automatically included.
var discoveries = []string{
	{{- range .Discoveries }}
	"{{- . }}",
	{{- end }}
}

/////////////////////////////////
// Boilerplate Object Methods //
///////////////////////////////

// Name returns the FQDN of the module
func (*{{- .Name }}) Name() string { return "{{- .PackageUrl }}" }

{{- if .WithConfig }}
// ConfigURL gives the any resolver URL for the config
func (*{{- .Name }}) ConfigURL() string {
	cfg := &Config{}
	any, _ := ptypes.MarshalAny(cfg)
	return any.GetTypeUrl()
}
{{ end }}

////////////////////////
// Wrapper functions //
//////////////////////

// Discover submits a discovery event
func Discover(node string, url string, value string) {
	nurl := util.NodeURLJoin(node, url)
	dchan <- core.NewEvent(
		types.Event_DISCOVERY,
		nurl,
		&core.DiscoveryEvent{
			URL:     nurl,
			ValueID: value,
		},
	)
}

// We intentionally exclude Update wrappers as these methods should generally be avoided.
// Use SetValue(s) instead.

// SetState is a helper function that discovers our own ServiceInstance State
type SelfState string

const (
	StateRun   SelfState = "RUN"
	StateStop  SelfState = "STOP"
	StateError SelfState = "ERROR"
)

// State sets our own (ServiceInstance) running state
func (mod *{{- .Name }}) State(s SelfState) {
	url := util.URLPush(util.URLPush("/Services", si.ID()), "State")
	Discover(self.String(), url, string(s))
}

// Listen for events.  This is used as our primary entrypoint function.
func (mod *{{- .Name }}) Listen() {
	// main loop
	for {
		select {
		{{- if .WithPolling }}
		case <-mod.pollTicker.C: // our ticker ticked
			go mod.Poll()
			break
		{{- end }}
		case m := <-mchan: // mutation request
			go mod.handleMutation(m)
			break
		}
	}
}

// SetMutationChan sets the current mutation channel
// this is generally done by the API
func (mod *{{- .Name }}) SetMutationChan(c <-chan types.Event) { mchan = c }

// SetDiscoveryChan sets the current discovery channel
// this is generally done by the API
func (mod *{{- .Name }}) SetDiscoveryChan(c chan<- types.Event) { dchan = c }

// Make some logging shortcuts
const (
	PANIC    = types.LLPANIC
	FATAL    = types.LLFATAL
	CRITICAL = types.LLCRITICAL
	ERROR    = types.LLERROR
	WARNING  = types.LLWARNING
	NOTICE   = types.LLNOTICE
	INFO     = types.LLINFO
	DEBUG    = types.LLDEBUG
	DDEBUG   = types.LLDDEBUG
	DDDEBUG  = types.LLDDDEBUG
)

// Log is a convenience function wrapping api.Log
func Log(level types.LoggerLevel, m string) {
	api.Log(level, m)
}

// Logf is a convenience function wrapping the api.Logf
func Logf(level types.LoggerLevel, fmt string, v ...interface{}) {
	api.Logf(level, fmt, v...)
}

////////////////////////
// Unexported methods /
//////////////////////

func hNotImplemented(mid string, cfg, dsc types.Node) {
	Logf(ERROR, "mutation request for node=%s, mutation=%s, but mutation is not implemented", cfg.ID().String(), mid)
}

func hInterruptUnhandled(*core.MutationEvent) {
	Logf(DDEBUG, "received a mutation interrupt, but interrupts are not currently handled")
}

// handle mutation events
func (mod *{{- .Name }}) handleMutation(m types.Event) {
	if m.Type() != types.Event_STATE_MUTATION {
		api.Log(types.LLINFO, "got an unexpected event type on mutation channel")
	}
	me := m.Data().(*core.MutationEvent)
	// mutation switch
	switch me.Type {
	case core.MutationEvent_MUTATE:
		mid := me.Mutation[1]
		if mdef, ok := mutations[mid]; ok {
			if mdef.Handler != nil {
				mdef.Handler(mid, me.NodeCfg, me.NodeDsc)
			} else {
				Logf(ERROR, "hanlder for mutation %s is nil", mid)
			}
		} else {
			Logf(types.LLDEBUG, "mutation request for undefined mutation: %s", me.Mutation[1])
		}
	case core.MutationEvent_INTERRUPT:
		// nothing to do
		interruptHandler(me)
	}
}

// initialization.  We rely on this to declare ourselves with Kraken.
func init() {
	module := &{{- .Name }}{}
	core.Registry.RegisterModule(module)

	si = core.NewServiceInstance("{{- .PackageName }}", module.Name(), module.Entry)
	core.Registry.RegisterServiceInstance(module, map[string]types.ServiceInstance{si.ID(): si})

	// Build list of mutations
	muts := make(map[string]types.StateMutation)
	for mid, mdef := range mutations {
		mut, err := core.CreateMutation(si, mdef)
		if err != nil {
			panic(err)
		}
		muts[mid] = mut
		// add mutators to discoverables
		for url := range mdef.Mutates {
			discoveries = append(discoveries, url)
		}
	}
	core.Registry.RegisterMutations(si, muts)

	// Build list of discoveries
	discs := make(map[string]map[string]reflect.Value)
	for _, url := range discoveries {
		d, err := core.CreateDiscovers(url)
		if err != nil {
			panic(err)
		}
		discs[url] = d
	}
	// Add our own service discoveries
	discs["/Services/{{- .PackageName }}/State"] = map[string]reflect.Value{
		"UNKNOWN": reflect.ValueOf(cpb.ServiceInstance_UNKNOWN),
		"INIT":    reflect.ValueOf(cpb.ServiceInstance_INIT),
		"STOP":    reflect.ValueOf(cpb.ServiceInstance_STOP),
		"RUN":     reflect.ValueOf(cpb.ServiceInstance_RUN),
		"ERROR":   reflect.ValueOf(cpb.ServiceInstance_ERROR),
	}
	core.Registry.RegisterDiscoverable(si, discs)
}
