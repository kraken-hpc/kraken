// Generated by kraken {{- .Global.Version }}. DO NOT EDIT
// To update, run `kraken module update`

package {{ .PackageName }}

import (
	fmt "fmt"
	"reflect"
	"time"

	proto "github.com/gogo/protobuf/proto"
	{{- if .WithConfig }}
	ptypes "github.com/gogo/protobuf/types"
	{{ end }}
	"github.com/kraken-hpc/kraken/core"
	cpb "github.com/kraken-hpc/kraken/core/proto"
	"github.com/kraken-hpc/kraken/lib/types"
	"github.com/kraken-hpc/kraken/lib/util"
)

///////////////////////
// Global Variables //
/////////////////////

var api types.ModuleAPIClient              // the ModuleAPI client
var self types.NodeID                      // our own node ID
var si types.ServiceInstance               // our own service instance
var mchan <-chan types.Event               // mutation event channel (recieve)
var dchan chan<- types.Event               // discovery event channel (send)
var interruptHandler = hInterruptUnhandled // set this in order to process mutation interrupts

///////////////////////////
// Mutation Definitions //
/////////////////////////

// a mutation object records mutations as strings
// we have to lookup types & values at runtime
type mutation struct {
	mutates  map[string][2]string
	requires map[string]string
	excludes map[string]string
	context  string
	timeout  string
	failto   [2]string
	handler  func(mut string, cfg, dsc types.Node)
}

var mutations = map[string]*mutation{
	{{- range $name, $mutation := .Mutations }}
	"{{- $name }}": {
		mutates: map[string][2]string{
			{{- range $url, $values := $mutation.Mutates }}
			"{{- $url }}": {"{{- $values.From }}", "{{- $values.To }}"},
			{{- end }}
		},
		requires: map[string]string{
			{{- range $url, $value := $mutation.Requires }}
			"{{- $url }}": "{{- $value }}",
			{{- end }}
		},
		excludes: map[string]string{
			{{- range $url, $value := $mutation.Excludes }}
			"{{- $url }}": "{{- $value }}",
			{{- end }}
		},
		context: "{{- $mutation.Context }}",
		timeout: "{{- $mutation.Timeout }}",
		failto:  [2]string{"{{- $mutation.FailTo.Url }}", "{{- $mutation.FailTo.Value }}"},
	},
	{{- end }}
}

////////////////////////////
// Discovery Definitions //
//////////////////////////

// Note: Discoveries that are implicit by mutations are automatically included
//       Discoveries for the service state are automatically included.
var discoveries = []string{
	{{- range .Discoveries }}
	"{{- . }}",
	{{- end }}
}

/////////////////////////////////
// Boilerplate Object Methods //
///////////////////////////////

// Name returns the FQDN of the module
func (*{{- .Name }}) Name() string { return "{{- .PackageUrl }}" }

{{- if .WithConfig }}
// ConfigURL gives the any resolver URL for the config
func (*{{- .Name }}) ConfigURL() string {
	cfg := &Config{}
	any, _ := ptypes.MarshalAny(cfg)
	return any.GetTypeUrl()
}
{{ end }}

////////////////////////
// Wrapper functions //
//////////////////////

// Discover submits a discovery event
func Discover(node string, url string, value string) {
	nurl := util.NodeURLJoin(node, url)
	dchan <- core.NewEvent(
		types.Event_DISCOVERY,
		nurl,
		&core.DiscoveryEvent{
			URL:     nurl,
			ValueID: value,
		},
	)
}

// We intentionally exclude Update wrappers as these methods should generally be avoided.
// Use SetValue(s) instead.

// SetState is a helper function that discovers our own ServiceInstance State
type SelfState string

const (
	StateRun   SelfState = "RUN"
	StateStop  SelfState = "STOP"
	StateError SelfState = "ERROR"
)

// State sets our own (ServiceInstance) running state
func (mod *{{- .Name }}) State(s SelfState) {
	url := util.URLPush(util.URLPush("/Services", si.ID()), "State")
	Discover(self.String(), url, string(s))
}

// Listen for events.  This is used as our primary entrypoint function.
func (mod *{{- .Name }}) Listen() {
	// main loop
	for {
		select {
		{{- if .WithPolling }}
		case <-mod.pollTicker.C: // our ticker ticked
			go mod.Poll()
			break
		{{- end }}
		case m := <-mchan: // mutation request
			go mod.handleMutation(m)
			break
		}
	}
}

// SetMutationChan sets the current mutation channel
// this is generally done by the API
func (mod *{{- .Name }}) SetMutationChan(c <-chan types.Event) { mchan = c }

// SetDiscoveryChan sets the current discovery channel
// this is generally done by the API
func (mod *{{- .Name }}) SetDiscoveryChan(c chan<- types.Event) { dchan = c }

// Make some logging shortcuts
const (
	PANIC    = types.LLPANIC
	FATAL    = types.LLFATAL
	CRITICAL = types.LLCRITICAL
	ERROR    = types.LLERROR
	WARNING  = types.LLWARNING
	NOTICE   = types.LLNOTICE
	INFO     = types.LLINFO
	DEBUG    = types.LLDEBUG
	DDEBUG   = types.LLDDEBUG
	DDDEBUG  = types.LLDDDEBUG
)

// Log is a convenience function wrapping api.Log
func Log(level types.LoggerLevel, m string) {
	api.Log(level, m)
}

// Logf is a convenience function wrapping the api.Logf
func Logf(level types.LoggerLevel, fmt string, v ...interface{}) {
	api.Logf(level, fmt, v...)
}

////////////////////////
// Unexported methods /
//////////////////////

func hNotImplemented(mid string, cfg, dsc types.Node) {
	Logf(ERROR, "mutation request for node=%s, mutation=%s, but mutation is not implemented", cfg.ID().String(), mid)
}

func hInterruptUnhandled(*core.MutationEvent) {
	Logf(DDEBUG, "received a mutation interrupt, but interrupts are not currently handled")
}

// handle mutation events
func (mod *{{- .Name }}) handleMutation(m types.Event) {
	if m.Type() != types.Event_STATE_MUTATION {
		api.Log(types.LLINFO, "got an unexpected event type on mutation channel")
	}
	me := m.Data().(*core.MutationEvent)
	// mutation switch
	switch me.Type {
	case core.MutationEvent_MUTATE:
		mid := me.Mutation[1]
		if mdef, ok := mutations[mid]; ok {
			if mdef.handler != nil {
				mdef.handler(mid, me.NodeCfg, me.NodeDsc)
			} else {
				Logf(ERROR, "hanlder for mutation %s is nil", mid)
			}
		} else {
			Logf(types.LLDEBUG, "mutation request for undefined mutation: %s", me.Mutation[1])
		}
	case core.MutationEvent_INTERRUPT:
		// nothing to do
		interruptHandler(me)
	}
}

// LookupEnum finds an enum and its value map based on URL
func LookupEnum(url string) (enumName string, enumType reflect.Type, valueMap map[string]int32, err error) {
	n := core.NewNodeWithID("00000000-0000-0000-0000-000000000000")
	name, base := util.URLShift(url)
	v, err := n.GetValue(base)
	if err != nil {
		fmt.Println("HERE: " + err.Error())
		return
	}
	switch v.Kind() {
	case reflect.Struct:
		props := proto.GetProperties(v.Type())
		found := false
		for _, p := range props.Prop {
			if p.Name == name {
				// found
				if p.Enum == "" {
					err = fmt.Errorf("property %s in %s is not an enum", name, base)
					return
				}
				// ok, we found it
				enumName = p.Enum
				valueMap = proto.EnumValueMap(enumName)
				if valueMap == nil {
					err = fmt.Errorf("got nil value map for enum %s in %s", name, base)
				}
				sf := v.FieldByName(name)
				enumType = sf.Type()
				return
			}
		}
		if !found {
			err = fmt.Errorf("not found: no property by name %s in %s", name, base)
			return
		}
	case reflect.Map, reflect.Slice:
		err = fmt.Errorf("not found: looking up enums as slice or map elements is not yet supported: %s", url)
		return
	default:
		err = fmt.Errorf("not found: url base is not a valid container type: %s", url)
		return
	}
	return
}

// MustLookupEnum performs LookupEnum, but panics if enum lookup fails
func MustLookupEnum(url string) (enumName string, enumType reflect.Type, valueMap map[string]int32) {
	var err error
	enumName, enumType, valueMap, err = LookupEnum(url)
	if err != nil {
		panic(err)
	}
	return
}

// LookupEnumValue maps an enum value to a reflect.Value based on URL and value string
func LookupEnumValue(url string, value string) (interface{}, error) {
	if _, et, vm, err := LookupEnum(url); err == nil {
		if v, ok := vm[value]; ok {
			return reflect.ValueOf(v).Convert(et).Interface(), nil
		} else {
			return 0, fmt.Errorf("enum %s has not such value %s", url, value)
		}
	} else {
		return 0, fmt.Errorf("enum %s not found", url)
	}
}

// MustLookupEnumValue performs LookupEnumValue, but panics if lookup fails
func MustLookupEnumValue(url string, value string) interface{} {
	v, err := LookupEnumValue(url, value)
	if err != nil {
		panic(err)
	}
	return v
}

var StateMutationContext_names = map[string]types.StateMutationContext{
	"SELF":  types.StateMutationContext_SELF,
	"CHILD": types.StateMutationContext_CHILD,
	"ALL":   types.StateMutationContext_ALL,
}

func valueFromString(url, value string) (v reflect.Value, err error) {
	n := core.NewNodeWithID("00000000-0000-0000-0000-000000000000")
	var rv reflect.Value
	if rv, err = n.GetValue(url); err != nil {
		return
	}
	nys := fmt.Errorf("valueFromString: type not yet supported")
	switch rv.Kind() {
	case reflect.Int, reflect.Int32, reflect.Int16, reflect.Int64:
		if rv.Kind() == reflect.Int32 {
			// might be an enum
			if i, err := LookupEnumValue(url, value); err == nil {
				return reflect.ValueOf(i), nil
			}
		}
		return v, nys
	case reflect.Uint, reflect.Uint32, reflect.Uint16, reflect.Uint64:
		return v, nys
	case reflect.Float32, reflect.Float64:
		return v, nys
	case reflect.String:
		// the easy one...
		return reflect.ValueOf(value), nil
	case reflect.Bool:
		return v, nys
	default:
		return v, fmt.Errorf("unsupported kind: %s", rv.Kind())
	}
}

func mustValueFromString(url, value string) reflect.Value {
	v, err := valueFromString(url, value)
	if err != nil {
		panic(fmt.Sprintf("mustValueFromString error: url=%s, value=%s, err=%v", url, value, err))
	}
	return v
}

// createMutation turns a string mutation definition into a StateMutation
func createMutation(m *mutation) (types.StateMutation, error) {
	mut := map[string][2]reflect.Value{}
	for url, vs := range m.mutates {
		mut[url] = [2]reflect.Value{
			reflect.ValueOf(MustLookupEnumValue(url, vs[0])),
			reflect.ValueOf(MustLookupEnumValue(url, vs[1])),
		}
	}
	req := map[string]reflect.Value{}
	for url, v := range m.requires {
		req[url] = mustValueFromString(url, v)
	}
	exc := map[string]reflect.Value{}
	for url, v := range m.excludes {
		exc[url] = mustValueFromString(url, v)
	}
	timeout, err := time.ParseDuration(m.timeout)
	if err != nil {
		panic("invalid time duration in mutation: " + m.timeout)
	}
	return core.NewStateMutation(mut, req, exc, StateMutationContext_names[m.context], timeout, [3]string{si.ID(), m.failto[0], m.failto[1]}), nil
}

func createDiscovers(url string) (map[string]reflect.Value, error) {
	_, et, valueMap, err := LookupEnum(url)
	if err != nil {
		return nil, fmt.Errorf("%s isn't a valid enum: %v", url, err)
	}
	r := map[string]reflect.Value{}
	for k, v := range valueMap {
		r[k] = reflect.ValueOf(v).Convert(et)
	}
	return r, nil
}

// initialization.  We rely on this to declare ourselves with Kraken.
func init() {
	module := &{{- .Name }}{}
	core.Registry.RegisterModule(module)

	si = core.NewServiceInstance("{{- .PackageName }}", module.Name(), module.Entry)
	core.Registry.RegisterServiceInstance(module, map[string]types.ServiceInstance{si.ID(): si})

	// Build list of mutations
	muts := make(map[string]types.StateMutation)
	for mid, mdef := range mutations {
		mut, err := createMutation(mdef)
		if err != nil {
			panic(err)
		}
		muts[mid] = mut
		// add mutators to discoverables
		for url := range mdef.mutates {
			discoveries = append(discoveries, url)
		}
	}
	core.Registry.RegisterMutations(si, muts)

	// Build list of discoveries
	discs := make(map[string]map[string]reflect.Value)
	for _, url := range discoveries {
		d, err := createDiscovers(url)
		if err != nil {
			panic(err)
		}
		discs[url] = d
	}
	// Add our own service discoveries
	discs["/Services/{{- .PackageName }}/State"] = map[string]reflect.Value{
		"UNKNOWN": reflect.ValueOf(cpb.ServiceInstance_UNKNOWN),
		"INIT":    reflect.ValueOf(cpb.ServiceInstance_INIT),
		"STOP":    reflect.ValueOf(cpb.ServiceInstance_STOP),
		"RUN":     reflect.ValueOf(cpb.ServiceInstance_RUN),
		"ERROR":   reflect.ValueOf(cpb.ServiceInstance_ERROR),
	}
	core.Registry.RegisterDiscoverable(si, discs)
}
